####################################################
# DVrouter.py
# Name: Nguyen Thu Ha va Tran Phuong Phuong
# HUID: 23020532      va  23020562
#####################################################
import json

from router import Router
from packet import Packet
INFINITY = 16  # Giới hạn chi phí để tránh count-to-infinity
class DVrouter(Router):
    """Distance vector routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here
        self.dv_table = {addr: 0}  #dest -> (cost)
        self.forwarding_table = {} # dest -> (port)
        self.neighbors = {}  #port -> (dest,cost)
        pass

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            """ 
                nếu contains packet.dst_addr -> gửi cổng tiếp 
                Đây là gói tin để kiểm tra đường đi → chuyển tiếp tiếp theo
            """
            if packet.dst_addr in self.forwarding_table:
                ## xem pkt muốn truyền ra cổng nào tra forwarding table
                self.send(self.forwarding_table[packet.dst_addr], packet)
            pass
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the received distance vector is different
            #   update the local copy of the distance vector
            #   update the distance vector of this router
            #   update the forwarding table
            #   broadcast the distance vector of this router to neighbors

            # Giải mã vector khoảng cách từ láng giềng
            neighbor_vector = json.loads(packet.content) #load từ STRING
            updated = False

            # Cập nhật vector khoảng cách
            ##endpoint, cost
            for dest, dist in neighbor_vector.items():
                if dest not in self.dv_table or dist + self.neighbors[port][1] < self.dv_table[dest]:
                    self.dv_table[dest] = min(dist + self.neighbors[port][1], INFINITY)
                    self.forwarding_table[dest] = port
                    updated = True
                elif self.forwarding_table.get(dest) == port and dist + self.neighbors[port][1] > self.dv_table[
                    dest]:
                    # Cập nhật nếu khoảng cách từ láng giềng tăng
                    self.dv_table[dest] = min(dist + self.neighbors[port][1], INFINITY)
                    updated = True
            # Nếu vector thay đổi, phát quảng bá
            if updated:
                self.broadcast_distance_vector()
            pass


    def broadcast_distance_vector(self):
        dv_tmp = {dest: cost for dest, cost in self.dv_table.items()}
        for port in self.links:
            packet = Packet(
                kind=Packet.ROUTING,
                src_addr=self.addr,
                dst_addr=None,
                content=json.dumps(dv_tmp) # ndung pkt là string -> json.dumps chuyển sang string
            )
            self.send(port, packet)

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors
        """ LINK mới connect
            endpoint: địa chỉ của router mới thêm
        """
        ##update hàng xóm
        self.neighbors[port] = (endpoint, cost)
        self.dv_table[endpoint] = cost
        self.forwarding_table[endpoint] = port

        # Gửi bảng DV cho tất cả neighbor
        self.broadcast_distance_vector()
        pass

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update the distance vector of this router
        #   update the forwarding table
        #   broadcast the distance vector of this router to neighbors

        if port in self.neighbors:
            del self.neighbors[port]
            updated = False
            for dest in list(self.forwarding_table):
                if self.forwarding_table[dest] == port:
                    self.dv_table[dest] = INFINITY
                    del self.forwarding_table[dest]
                    updated = True
            if updated:
                self.broadcast_distance_vector()
    pass

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the distance vector of this router to neighbors
            """  Kiểm tra nếu đã đến lúc gửi "heartbeat" (gửi lại distance vector).
                broadcast
            """
            self.broadcast_distance_vector()
            pass

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        """ in ra console dễ đọc """
        return (f"DVrouter(\n"
                f"  addr={self.addr},\n"
                f"  dv_table [dest->cost] ={self.dv_table},\n"
                f"  forwarding_table [dest->port]={self.forwarding_table},\n"
                f"  neighbors[port -> (dest,cost)]={self.neighbors}\n"
                f")")
